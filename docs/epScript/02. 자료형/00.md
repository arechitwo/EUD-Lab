# EUDVariable (var, const)

`EUDVariable`는 가장 기본이 되는 자료형으로, 기본적으로 <mark>숫자</mark>만 저장할 수 있습니다. 이때 숫자는 124, 65 같은 정수형 숫자만 저장합니다. 124.45 같은 실수는 저장할 수 없습니다.  

## 어떻게 만들고 사용할까?

변수는 흔히 값을 넣을 수 있는 빈 상자와 같다고 표현합니다. 즉, 변수는 값을 대입하여 사용할 수 있습니다. 그리고 값에는 어떤 형태가 정해져야 하는데, 이 형태가 바로 자료형입니다.

```js
var a;
const b;
```

위의 a,b를 변수(variable)라고 합니다. 이때, 변수의 이름은 개발자가 마음대로 작명할 수 있습니다.

```js
var one;
const two;
```

변수 이름을 지을 때는 3가지 규칙을 따라야 하는데,

1. 변수명은 숫자로 시작할 수 없다.
2. _ 이외의 특수 문자는 사용할 수 없다.
3. 이미 사용중인 키워드(`e.g. var, const`)는 변수명으로 사용할 수 없다.

다음은 사용할 수 없는 변수명의 예시입니다.

```js
var 1player;    // 숫자로 시작할 수 없다
const color#;   // #과 같은 특수문자는 사용할 수 없다
var const;      // const는 프로그래밍 언어에서 EUDVariable 변수를 선언하기 위한 약속된 키워드
```

!!! tip "약속된 키워드 알아두기"

    변수명을 정할 때 반드시 피해야 하는 키워드는 다음과 같습니다.
    ```
    var const if else for while continue break
    switch this raise and or as del class def
    from global import in is lambda nonlocal not
    or pass return try with yield False True None
    ...
    ```

## 자료형 알아보기

변수명의 앞의 var, const는 epScript에서 가장 기본이 되는 `EUDVariable` 자료형을 선언하는 키워드입니다. 앞서, `var a;`라는 코드는 아래와 같이 해석됩니다.

```js
var a; // a라는 변수는 EUDVariable으로 선언합니다
```

## 변수에 값 대입하기

변수를 선언한 후에는 변수에 값을 대입할 수 있습니다. 이때 `=` 기호를 사용합니다. 각 문장은 다음과 같이 해석됩니다.

```js
var a;
a = 1; // 변수 a에 1을 대입합니다.
```

> `=` 은 대입 연산자(assignment operator)라고 한다.

또한, 다음과 같이 변수를 선언함과 동시에 값을 대입할 수도 있습니다.


```js
var 변수1 = 0;
const 변수2 = 55;
```

위와 같이 `var 변수이름 = 값;` 혹은 `const 변수이름 = 값;` 형태로 만들 수 있습니다.  
이때 <mark>var은 값이 변할 수 있다고 하여 변수</mark>라고 부르며, <mark>const는 변하지 않는 수라고 하여 상수</mark>라고 부릅니다.  

!!! warning

    상수는 변하지 않는 수이기 때문에, 선언할 때 반드시 값을 대입해야 합니다.
    
    ```js
    const 변수; // 빌드 오류 -- 값이 없는 상수는 아무 의미 없는 쓰레기변수다.
    ```

## 연산자

**연산자(Operator)**는 값(피연산자)들에 대해 특정한 연산(계산 또는 비교 등)을 수행하는 기호 또는 키워드입니다.  

### 사칙연산

```js
var a = 5;
var b = 2;

simpleprint(a + b); // 7  -- a와 b를 더한 값
simpleprint(a - b); // 3  -- a에서 b를 뺀 값
simpleprint(a * b); // 10 -- a와 b를 곱한 값
simpleprint(a / b); // 2  -- a를 b로 나눈 몫
simpleprint(a % b); // 1  -- a를 b로 나눈 나머지
```

<mark>simpleprint</mark>는 디버깅용 DisplayText의 일종으로, 변수의 출력도 지원합니다. `DisplayText`는 변수를 출력할 수 없으며, 순수 텍스트만 출력할 수 있습니다. [^1]  

!!! warning

    이때, const 변수를 연산에 사용할 수 있지만 const 변수에 연산결과를 대입할 순 없습니다.
    
    ```js
    const a = 5;
    var b = 2;
    
    simpleprint(a + b); // 7
    a = a + b; // a는 const로 상수이기 때문에 대입 불가능
    ```

### 복합연산자

복합 연산자는 앞서 살펴본 `+`, `-` 와 같은 산술 연산자와 `대입 연산자(=)`를 합쳐 놓은 것입니다. 만약, a라는 변수에 1을 더하고 싶다면 아래와 같이 할 수 있습니다.

```js
var a = 0;
a = a + 1;
```

`a = a + 1;` 식에 의해 a의 값이 1만큼 증가하는데, `a = a + 1;`과 같은 표현식은 값을 증가시키기 위해 자주 사용합니다. 하지만 이 표현식은 다음과 같이 더 간략하게 표현할 수도 있습니다.

```js
a += 1;
```

`a += 1;`이라는 표현식은 `a = a + 1;`을 줄여서 표현한 것으로 완전히 동일한 기능을 합니다. 여기에서 사용한 `+=` 와 같은 연산자를 <mark>복합 연산자</mark>라 부릅니다. 복합연산자는 더하기만 있는게 아니고, 다른 사칙연산도 존재합니다.

```
+=, -=, *=, /=, %=
```

### 비트연산자

해당 부분은 지금 당장 공부할 필요는 없습니다. 해당 부분을 더 쉽게 이해하려면 `비트연산`에 대해서 먼저 공부하시는걸 추천합니다.

```js
const a = 6;
const b = 3;

simpleprint(a & b); // AND 연산 -- 두 비트 모두 1일 경우에만 1, b0110 & b0011 = b0010 = 2
simpleprint(a | b); // OR 연산  -- 두 비트 중 하나라도 1이면 1, b0110 | b0011 = b0111 = 7
simpleprint(a ^ b); // XOR 연산 -- 두 비트가 서로 다를 경우 1, b0110 ^ b0011 = b0101 = 5
simpleprint(~ a); // NOT 연산 -- 비트를 반전시킵니다. 1은 0으로, 0은 1로 바뀜, ~ b0110 = b1111 1111 1111 1111 1111 1111 1111 1001 = 4,294,967,289
simpleprint(a << 2); // 왼쪽 시프트 연산 -- 비트를 왼쪽으로 지정된 수만큼 이동, b0110 << 2 = b0001 1000 = 24
simpleprint(a >> 2); // 오른쪽 시프트 연산 -- 비트를 오른쪽으로 지정된 수만큼 이동, b0110 >> 2 = b0001 = 1
```


[^1]: 정확히는 DisplayText는 EUD트리거가 아닌 Classic트리거로, EUD기법을 활용한 변수는 출력할 수 없습니다.
