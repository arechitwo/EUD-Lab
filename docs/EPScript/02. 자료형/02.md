# UnitGroup

`UnitGroup`은 epScript에서 여러 유닛을 효율적으로 **그룹화**하고 관리할 수 있는 자료구조입니다.  
유닛의 EPD 를 순회할 때 순서를 고려할 필요가 없고 소 ~ 중 규모 그룹을 순회할 때 적합합니다.(대규모 그룹일 때는 EUDLoopUnit 를 고려할 필요가 있습니다.)

---

## 1. UnitGroup이란 무엇인가?

스타크래프트에서 특정 유닛들을 일괄적으로 제어하려면,  
각각의 EPD 주소를 직접 관리해야 하는데 `UnitGroup`은 **EPD를 기반으로 유닛을 저장하고 제어할 수 있는 컨테이너** 와 `cploop` 와 같은 기능을 제공합니다.
이를 통해 특정 조건을 만족하는 유닛만 그룹에 모아 순회하거나 일괄 처리할 수 있습니다.

---

## 2. 주요 특징

- 여러 유닛을 하나의 그룹으로 묶어 관리
- 유닛 **추가 / 제거 / 순회 / 초기화** 기능 제공
- 그룹 단위로 상태 관리 및 명령 실행 가능
- 코드 가독성과 유지보수성이 향상됨

---

## 3. 기본 메서드

### `add(unit_epd)`
유닛의 EPD를 그룹에 추가합니다.

```js
const marines = UnitGroup(1000);  // 최대 1000개의 유닛을 저장할 수 있는 그룹 생성
marines.add(marineEPD);  // 개별 유닛 추가
```

---

### `cploop`
그룹에 포함된 모든 유닛을 순회하면서 처리합니다. CurrentPlayer를 해당 유닛의 EPD로 설정하면서 순회합니다.

```js
foreach(unit : marines.cploop) {
    // unit.dying으로 죽은 유닛 감지 가능
    foreach(dead : unit.dying) {
        // 죽은 유닛 처리
        // dying 블록이 끝나면 자동으로 remove() 호출
    }
    // 살아있는 유닛 처리
}
```

---

### `dying`
유닛이 죽었는지 확인하고 처리할 수 있는 블록을 제공합니다.
죽은 유닛은 블록이 끝날 때 자동으로 그룹에서 제거됩니다.

---

### `remove()`
현재 순회 중인 유닛을 그룹에서 제거합니다.
주의: `dying` 블록 안에서는 직접 호출하지 마세요. 자동으로 호출됩니다.

```js
foreach(unit : marines.cploop) {
    if (condition) {
        unit.remove();  // 조건에 따라 수동으로 제거
    }
}
```

---

### `length`
그룹에 포함된 유닛의 수를 반환합니다. (읽기 전용)

```js
const count = marines.length;  // 현재 그룹에 포함된 유닛 수
```

---

### `move_cp(offset)`와 `set_cp(offset)`
이 두 메서드는 CurrentPlayer를 조작하여 유닛의 메모리에 접근하는 방법을 제공합니다.
트리거 코드 생성 시점에서의 차이점이 중요합니다:

- `move_cp`: 현재 위치에서의 **상대적인 이동**을 생성
  - 이전 위치를 기준으로 계산된 트리거를 생성
  - if문이나 반복문에서 현재 위치 추적이 어려울 수 있음
  - 제어문이 복잡할수록 의도하지 않은 위치로 이동할 위험 존재
  - 연속된 메모리 접근에는 효율적이나, 제어문 내에서는 주의 필요

- `set_cp`: **절대적인 위치**로의 이동을 생성
  - 항상 유닛의 시작 위치를 기준으로 계산
  - 조건문과 관계없이 동일한 위치로 이동
  - 독립적인 메모리 접근에 유용

```js
foreach(unit : marines.cploop) {
    if(condition) {
        // move_cp: 현재 위치에서 상대적으로 이동
        unit.move_cp(0x08/4);  // HP 위치로
        const hp1 = bread_cp(0, 0);
        
        unit.move_cp(0x4C/4 - 0x08/4);  // 소유자 위치로 (이전 위치 기준)
        const owner = bread_cp(0, 0);
    } else {
        // set_cp: 절대적인 위치로 이동
        unit.set_cp(0x08/4);  // 직접 HP 위치로
        const hp2 = bread_cp(0, 0);
        
        unit.set_cp(0x4C/4);  // 직접 소유자 위치로
        const owner = bread_cp(0, 0);
    }
}
```

두 메서드는 조건문이나 반복문 안에서 트리거가 생성되는 방식에 차이가 있습니다.
`move_cp`는 현재 위치를 추적하면서 트리거를 생성하지만, 복잡한 제어문에서는 위치 추적이 실패할 수 있습니다.
반면 `set_cp`는 매번 절대 위치로 이동하는 트리거를 생성하므로 제어문과 관계없이 안전합니다. 효율적인 순환과 cp트릭 활용을 위해 이부분을 주의해야합니다.

```js
// 주의: move_cp 사용 시 제어문에서의 위험 예시
foreach(unit : marines.cploop) {
    if(condition1) {
        unit.move_cp(0x08/4);  // HP 위치로
        if(condition2) {
            // 여기서의 위치가 예상과 다를 수 있음
            unit.move_cp(0x4C/4);  // 의도한 위치로 이동하지 않을 수 있음
        }
    }
}

// 안전: set_cp 사용
foreach(unit : marines.cploop) {
    if(condition1) {
        unit.set_cp(0x08/4);  // 항상 HP 위치로
        if(condition2) {
            // 항상 정확한 위치로 이동
            unit.set_cp(0x4C/4);  // 항상 소유자 위치로
        }
    }
}
```

```js
foreach(unit : marines.cploop) {
    // HP 위치로 직접 이동
    unit.set_cp(0x08/4);
    const hp = bread_cp(0, 0);
    
    // 위치 좌표로 직접 이동
    unit.set_cp(0x28/4);
    const x, y = posread_cp(0);
}
```

---

## 4. 사용 예시

저체력 유닛을 감지하고 치료하는 예시입니다:

```js
const lowHpUnits = UnitGroup(1000);

function afterTriggerExec() {
    // 새로 생성된 유닛들 중에서 체력이 낮은 유닛 찾기
    foreach(cunit : EUDLoopNewCUnit()) {
        const hp = dwread_epd(cunit + 0x08/4);
        if (hp <= 50) {
            lowHpUnits.add(cunit);
        }
    }

    // 그룹 내 유닛들 처리
    foreach(unit : lowHpUnits.cploop) {
        foreach(dead : unit.dying) {
            // 죽은 유닛 처리
            eprintf("유닛이 치료받기 전에 죽었습니다.");
        }
        // 살아있는 유닛 치료
        const unitEPD = unit.epd;
        dwwrite_epd(unitEPD + 0x08/4, 100);  // HP를 100으로 설정
    }
}
```

---

## 5. 주의할 점

- `UnitGroup`은 생성 시 지정한 **최대 용량** 이상의 유닛을 저장할 수 없습니다.
- `dying` 블록 안에서는 `remove()`를 직접 호출하지 마세요.
- 모든 유닛이 포함된 그룹은 그룹화 할 필요 없는 그룹입니다. `EUDLoopUnit`을 고려하세요.
- 그룹 순회 시에는 `cploop`를 사용하세요.

---

## 6. 정리

- `UnitGroup`은 **유닛 EPD 관리의 복잡성을 줄이는 컨테이너**입니다.
- 순회 시 `cploop`를 통해 CurrentPlayer 조작을 자동화합니다.
- 죽은 유닛 처리를 위한 `dying` 블록을 제공합니다.
- 메모리 효율을 위해 정해진 크기로 관리됩니다.

---

